#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
double mean(vector<double> &x)
{
    // to return mean
    double mean = 0;
    for (double t : x)
        mean += t;
    return mean / x.size();
}
double regCoEff(vector<double> &y, vector<double> &x)
{
    double Y = mean(y), X = mean(x);
    double beta_1 = 0;  // regCoEff of y on x
    double beta_1N = 0; // N - numerator
    double beta_1D = 0; // D - denominator
    for (int i = 0; i < y.size(); i++)
    {
        beta_1N += ((x[i] - X) * (y[i] - Y));
        beta_1D += pow((x[i] - X), 2);
    }

    beta_1 = beta_1N / beta_1D;
    // if beta_1 is +ive then y increases with x ,if beta_1 is -ive then y
    decreases with x return beta_1;
}
double stdDeviation(vector<double> &x)
{
    // returns of standard deviation
    double meanOfX = mean(x);
    double numerator = 0;
    int n = x.size();
    for (int i = 0; i < x.size(); i++)
    {
        numerator += pow(x[i] - meanOfX, 2);
    }
    double stdDOfX = sqrt(numerator / (n - 1));
    return stdDOfX;
}
double variance(vector<double> &x)
{
    // return variance
    double meanOfX = mean(x);
    double numerator = 0;
    int n = x.size();
    for (int i = 0; i < x.size(); i++)
    {
        numerator += pow(x[i] - meanOfX, 2);
    }
    double variance = (numerator / (n - 1));
    return variance;
}
double rSq(vector<double> &x, vector<double> &y, double beta_1)
{
    // return R-Squared value of two DataSets
    // rSquared = var(beta_1*x)/var(y)
    // varOf_beta_1_x -> var(beta_1*x)
    // beta_1 is regCoEff of y on x
    vector<double> beta_1_x;
    for (int i = 0; i < x.size(); i++)
        beta_1_x.push_back(beta_1 * x[i]);
    double varOf_beta_1_x = variance(beta_1_x);
    double varOfY = variance(y);
    double rSquared = varOf_beta_1_x / varOfY;

    return rSquared;
}
double stdDOfRC(vector<double> &x, vector<double> &y)
{
    // for std deviation of reg coeff
    // winSize = windowSize i.e interval spacing for finding confidence interval
    of regCoEff int winSize = 10;
    vector<double> RCs; // to store regCoEff of different intervals
    // setting the interval(window) and then calculating regCoEff of each
    interval and pushing tht regCoEff into RC vector
        // tempX is a pointer for x vector nd y vector
        // i is a pointer for curr distinct interval generated
        for (int tempX = 0; tempX < x.size();)
    {
        vector<double> xPart; // distinct interval vector of x vector of size =
        winSize
            vector<double>
                yPart; // distinct interval vector of y vector of size =
        winSize for (int i = 1; i <= winSize and tempX < x.size(); i++, tempX++)
        {
            xPart.push_back(x[tempX]);
            yPart.push_back(y[tempX]);
        }
        double currRC = regCoEff(yPart, xPart); // currRC -> regCoEff of curr
        interval
            RCs.push_back(currRC);
    }
    // Finding and returning std deviation of RCs
    double meanOfRC = mean(RCs);
    double numerator = 0;
    for (int i = 0; i < RCs.size(); i++)
    {
        numerator += pow(RCs[i] - meanOfRC, 2);
    }
    double stdDOfRegCoEff = sqrt(numerator / (RCs.size() - 1));
    return stdDOfRegCoEff;
}
void estimate(vector<double> &x, vector<double> y)
{
    // for estimation
    double tempX;
    cout << "Enter x: ";
    cin >> tempX;
    double beta_1 = regCoEff(y, x);                       // beat_1 is regCoEff of y on x of entire data
    double beta_0 = mean(y) - (regCoEff(y, x) * mean(x)); // beta_0 -> intercept
    value of reg.line y on x of entire data
        // rSquared to pridict statistically significant relation
        double rSquared = rSq(x, y, beta_1);
    // point estimation on beta_1 and beta_0 of entire data
    cout << "point est y(" << tempX << ") = " << beta_0 + beta_1 * tempX << endl;
    // stdDOfBeta_1 -> standard deviation of RCs
    double stdDOfBeta_1 = stdDOfRC(x, y);
    // confidence interval
    // regression CoEfficient based interval classification
    double beta_1a = beta_1 - 2 * stdDOfBeta_1;
    double beta_1b = beta_1 + 2 * stdDOfBeta_1;
    // intercept based interval classification
    double beta_0a = mean(y) - (beta_1a * mean(x));
    double beta_0b = mean(y) - (beta_1b * mean(x));
    // Estimation based on confident interval
    // the value of y for x = tempX lies in [minY,maxY]
    double interval1 = beta_0a + (beta_1a * tempX), interval2 = beta_0b +
                                                                (beta_1b * tempX);
    double minY = min(interval1, interval2), maxY = max(interval1, interval2);
    cout << "Interval estimation y(" << tempX << ") lies in the 
        interval "<<"["<<minY<<", "<<maxY<<"] "<<endl;
}